{"results": {"content_files": {"name": "README.md", "path": "README.md", "content": "# <div align=\"left\"><img src=\"img/rapids_logo.png\" width=\"90px\"/>&nbsp;cuML - GPU Machine Learning Algorithms</div>\n\n[![Build Status](https://gpuci.gpuopenanalytics.com/job/rapidsai/job/gpuci/job/cuml/job/branches/job/cuml-branch-pipeline/badge/icon)](https://gpuci.gpuopenanalytics.com/job/rapidsai/job/gpuci/job/cuml/job/branches/job/cuml-branch-pipeline/)\n\ncuML is a suite of libraries that implement machine learning algorithms and mathematical primitives functions that share compatible APIs with other [RAPIDS](https://rapids.ai/) projects.\n\ncuML enables data scientists, researchers, and software engineers to run\ntraditional tabular ML tasks on GPUs without going into the details of CUDA\nprogramming. In most cases, cuML's Python API matches the API from\n[scikit-learn](https://scikit-learn.org).\n\n\nFor large datasets, these GPU-based implementations can complete 10-50x faster\nthan their CPU equivalents. For details on performance, see the [cuML Benchmarks\nNotebook](https://github.com/rapidsai/notebooks-contrib/blob/master/intermediate_notebooks/benchmarks/cuml_benchmarks.ipynb).\n\nAs an example, the following Python snippet loads input and computes DBSCAN clusters, all on GPU:\n```python\nimport cudf\nfrom cuml.cluster import DBSCAN\n\n# Create and populate a GPU DataFrame\ngdf_float = cudf.DataFrame()\ngdf_float['0'] = [1.0, 2.0, 5.0]\ngdf_float['1'] = [4.0, 2.0, 1.0]\ngdf_float['2'] = [4.0, 2.0, 1.0]\n\n# Setup and fit clusters\ndbscan_float = DBSCAN(eps=1.0, min_samples=1)\ndbscan_float.fit(gdf_float)\n\nprint(dbscan_float.labels_)\n```\n\nOutput:\n```\n0    0\n1    1\n2    2\ndtype: int32\n```\n\ncuML also features multi-GPU and multi-node-multi-GPU operation, using [Dask](https://www.dask.org), for a\ngrowing list of algorithms. The following Python snippet reads input from a CSV file and performs\na NearestNeighbors query across a cluster of Dask workers, using multiple GPUs on a single node:\n```python\n# Create a Dask CUDA cluster w/ one worker per device\nfrom dask_cuda import LocalCUDACluster\ncluster = LocalCUDACluster()\n\n# Read CSV file in parallel across workers\nimport dask_cudf\ndf = dask_cudf.read_csv(\"/path/to/csv\")\n\n# Fit a NearestNeighbors model and query it\nfrom cuml.dask.neighbors import NearestNeighbors\nnn = NearestNeighbors(n_neighbors = 10)\nnn.fit(df)\nneighbors = nn.kneighbors(df)\n```\n\n\nFor additional examples, browse our complete [API\ndocumentation](https://docs.rapids.ai/api/cuml/stable/), or check out our\nintroductory [walkthrough\nnotebooks](https://github.com/rapidsai/notebooks/tree/master/cuml). Finally, you\ncan find complete end-to-end examples in the [notebooks-contrib\nrepo](https://github.com/rapidsai/notebooks-contrib).\n\n\n### Supported Algorithms\n| Category | Algorithm | Notes |\n| --- | --- | --- |\n| **Clustering** |  Density-Based Spatial Clustering of Applications with Noise (DBSCAN) | |\n|  | K-Means | Multi-node multi-GPU via Dask |\n| **Dimensionality Reduction** | Principal Components Analysis (PCA) | Multi-node multi-GPU via Dask|\n| | Truncated Singular Value Decomposition (tSVD) | Multi-node multi-GPU via Dask |\n| | Uniform Manifold Approximation and Projection (UMAP) | |\n| | Random Projection | |\n| | t-Distributed Stochastic Neighbor Embedding (TSNE) | |\n| **Linear Models for Regression or Classification** | Linear Regression (OLS) | Multi-node multi-GPU via Dask |\n| | Linear Regression with Lasso or Ridge Regularization | Multi-node multi-GPU via Dask |\n| | ElasticNet Regression | |\n| | Logistic Regression | |\n| | Stochastic Gradient Descent (SGD), Coordinate Descent (CD), and Quasi-Newton (QN) (including L-BFGS and OWL-QN) solvers for linear models  | |\n| **Nonlinear Models for Regression or Classification** | Random Forest (RF) Classification | Experimental multi-node multi-GPU via Dask |\n| | Random Forest (RF) Regression | Experimental multi-node multi-GPU via Dask |\n| | Inference for decision tree-based models | Forest Inference Library (FIL) |\n|  | K-Nearest Neighbors (KNN) | Multi-node multi-GPU via Dask, uses [Faiss](https://github.com/facebookresearch/faiss) for Nearest Neighbors Query. |\n|  | K-Nearest Neighbors (KNN) Classification | |\n|  | K-Nearest Neighbors (KNN) Regression | |\n|  | Support Vector Machine Classifier (SVC) | |\n|  | Epsilon-Support Vector Regression (SVR) | |\n| **Time Series** | Linear Kalman Filter | |\n|  | Holt-Winters Exponential Smoothing | |\n|  | Auto-regressive Integrated Moving Average (ARIMA) | Supports seasonality (SARIMA) |\n---\n\n## Installation\n\nSee [the RAPIDS Release\nSelector](https://rapids.ai/start.html#rapids-release-selector) for the command\nline to install either nightly or official release cuML packages via Conda or\nDocker.\n\n## Build/Install from Source\nSee the build [guide](BUILD.md).\n\n## Contributing\n\nPlease see our [guide for contributing to cuML](CONTRIBUTING.md).\n\n## References\n\nFor additional details on the technologies behind cuML, as well as a broader overview of the Python Machine Learning landscape, see [_Machine Learning in Python: Main developments and technology trends in data science, machine learning, and artificial intelligence_ (2020)](https://arxiv.org/abs/2002.04803) by Sebastian Raschka, Joshua Patterson, and Corey Nolet.\n\nPlease consider citing this when using cuML in a project. You can use the citation BibTeX:\n\n> @article{raschka2020machine,\n>   title={Machine Learning in Python: Main developments and technology trends in data science, machine learning, and artificial intelligence},\n>   author={Raschka, Sebastian and Patterson, Joshua and Nolet, Corey},\n>   journal={arXiv preprint arXiv:2002.04803},\n>   year={2020}\n> }\n\n## Contact\n\nFind out more details on the [RAPIDS site](https://rapids.ai/community.html)\n\n## <div align=\"left\"><img src=\"img/rapids_logo.png\" width=\"265px\"/></div> Open GPU Data Science\n\nThe RAPIDS suite of open source software libraries aim to enable execution of end-to-end data science and analytics pipelines entirely on GPUs. It relies on NVIDIA\u00ae CUDA\u00ae primitives for low-level compute optimization, but exposing that GPU parallelism and high-bandwidth memory speed through user-friendly Python interfaces.\n\n<p align=\"center\"><img src=\"img/rapids_arrow.png\" width=\"80%\"/></p>\n"}}}